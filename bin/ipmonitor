#!/usr/bin/env python3.7

import dns.resolver
import json
import argparse
import subprocess
import time
import os
import signal
import threading
import logging

state_file = '/var/db/ipmonitor.state'
proxy_table = 'proxylist'
bl_table = 'blacklist'

class Config:

    def __init__(self, file):
        if os.path.lexists(file):
            with open(file, 'r') as infile:
                self.config = json.load(infile)
        else:
            self.config = {}

    def get(self, path, default):
        current = self.config
        for part in path.split('.'):
            if not type(current) == type({}):
                raise Exception("path expected {}")
            if not part in current:
                return default
            current = current[part]
        return current

def get_ips(domain):
    try:
        return list(map(lambda r: str(r), dns.resolver.query(domain)))
    except dns.resolver.NXDOMAIN:
        return []

def pft_flush(table):
    subprocess.run(['pfctl', '-q', '-t', table, '-T', 'flush'], check=True)

def pft_add(table, ip):
    subprocess.run(['pfctl', '-q', '-t', table, '-T', 'add', ip], check=True)

def pft_remove(table, ip):
    subprocess.run(['pfctl', '-q', '-t', table, '-T', 'delete', ip], check=True)

def pft_list(table):
    output = subprocess.check_output(['pfctl', '-t', table, '-T', 'show'])
    ips = []
    for line in output.decode('utf-8').split('\n'):
        line = line.strip()
        if len(line) > 0:
            ips.append(line)
    return ips

class JsonState:

    def __init__(self):
        self.state = self._load()

    def _load(self):
        if os.path.lexists(state_file):
            with open(state_file, 'r') as infile:
                state = json.load(infile)
        else:
            state = {}
        return state

    def _save(self, state):
        data = json.dumps(state)
        with open(state_file, 'w') as outfile:
            outfile.write(data)

    def update_domain_ips(self, table, domain, ips):
        if not table in self.state:
            self.state[table] = {}
        if not domain in self.state[table]:
            self.state[table][domain] = {}
        for ip in ips:
            self.state[table][domain][ip] = time.time() + 3600
        self._save(self.state)

    def get_ips(self, table):
        ips = []
        if table in self.state:
            domain_remove = []
            for domain in self.state[table]:
                ip_remove = []
                for (ip, ttl) in self.state[table][domain].items():
                    if ttl > time.time():
                        ips.append(ip)
                    else:
                        ip_remove.append(ip)
                for ip in ip_remove:
                    del self.state[table][domain][ip]
                if len(self.state[table][domain]) == 0:
                    domain_remove.append(domain)
            for domain in domain_remove:
                del self.state[table][domain]
            if len(self.state[table]) == 0:
                del self.state[table]
            self._save(self.state)
        return ips

    def remove_domain(self, table, domain):
        del self.state[table][domain]
        if len(self.state[table]) == 0:
            del self.state[table]
        self._save(self.state)

    def get_domains(self, table):
        if table in self.state:
            return self.state[table].keys()
        return []

def prune_domains(config, state, table):
    # prune old domains that aren't in the list anymore
    to_remove = []
    for domain in state.get_domains(table):
        if not domain in config.get("%s.domains" % table, []):
            to_remove.append(domain)
    for domain in to_remove:
        state.remove_domain(table, domain)

def process_ips(config, state, table):
    for domain in config.get("%s.domains" % table, []):
        ips = get_ips(domain)
        state.update_domain_ips(table, domain, ips)

    pf_ips = pft_list(table)
    state_ips = state.get_ips(table)
    for ip in state_ips:
        if not ip in pf_ips:
            pft_add(table, ip)
    for ip in pf_ips:
        if not ip in state_ips:
            pft_remove(table, ip)

parser = argparse.ArgumentParser()
parser.add_argument('-c', help='config')
args = parser.parse_args()

logging.basicConfig(level=logging.INFO)

finish = threading.Event()
def on_signal(*args):
    finish.set()
signal.signal(signal.SIGINT, on_signal)
signal.signal(signal.SIGTERM, on_signal)

reload_config = True
def reload_signal(*args):
    global reload_config
    reload_config = True
signal.signal(signal.SIGUSR1, reload_signal)

state = JsonState()

while not finish.is_set():
    if reload_config:
        logging.info("reloading config")
        config = Config(args.c)
        prune_domains(config, state, proxy_table)
        prune_domains(config, state, bl_table)
        pft_flush(proxy_table)
        pft_flush(bl_table)
        reload_config = False

    process_ips(config, state, proxy_table)
    process_ips(config, state, bl_table)

    for i in range(60):
        if reload_config:
            break
        if finish.wait(1):
            break

pft_flush(proxy_table)
pft_flush(bl_table)
