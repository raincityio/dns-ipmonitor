#!/usr/bin/env python3.7

import socket
import re
import asyncio
import json
import argparse
import subprocess
import time
import os
import signal
import logging
import dnstap_client

default_state_file = '/var/db/ipmonitor.state'
default_config_file = "%s/.ipmonitor.json" % os.path.expanduser('~')

default_update_domains_period = 5
default_sync_period = 60
default_ttl = 3600

async def get_ips(domain):
    try:
        loop = asyncio.get_event_loop()
        records = await loop.getaddrinfo(domain, None)
        ips = []
        for record in records:
#            if not record[0] == socket.AF_INET:
#                continue
#            if not record[1] == socket.SOCK_STREAM:
#                continue
            ips.append(record[4][0])
        return ips
    except socket.gaierror:
        return []

async def pft_execute(table, cmd, *args):
    cmd_args = ['-q', '-t', table, '-T', cmd]
    cmd_args.extend(args)
    logging.debug('pfctl %s' % ' '.join(cmd_args))
    rc = await (await asyncio.create_subprocess_exec('pfctl', *cmd_args)).wait()
    if not rc == 0:
        raise Exception("pfctl failed")

async def pft_flush(table):
    await pft_execute(table, 'flush')

async def pft_add(table, ip):
    await pft_execute(table, 'add', ip)

async def pft_delete(table, ip):
    await pft_execute(table, 'delete', ip)

async def pft_list(table):
    proc = await asyncio.create_subprocess_exec('pfctl', '-q', '-t', table, '-T', 'show', stdout=asyncio.subprocess.PIPE)
    try:
        ips = []
        while True:
            line = await proc.stdout.readline()
            if len(line) == 0:
                break
            ips.append(line.decode('ascii').strip())
    finally:
        await proc.wait()
    if not proc.returncode == 0:
        raise Exception("pfctl failed")
    return ips

class JsonState:

    def __init__(self, state_file):
        self.state_file = state_file
        self.state = JsonState._load(state_file)

    @staticmethod
    def _load(state_file):
        if os.path.exists(state_file):
            with open(state_file, 'r') as infile:
                state = json.load(infile)
        else:
            state = {}
        return state

    def save(self):
        data = json.dumps(self.state)
        with open(self.state_file, 'w') as outfile:
            outfile.write(data)

    def get_tables(self):
        return self.state.keys()

    def get_domains(self, table):
        if not table in self.state:
            return []
        table = self.state[table]
        return table.keys()

    def remove_domain(self, table, domain):
        del self.state[table][domain]

    def remove_table(self, table):
        del self.state[table]

    def add_table(self, table):
        if not table in self.state:
            self.state[table] = {}

    def update_domain(self, table, domain, ips):
        if not table in self.state:
            self.state[table] = {}
        table = self.state[table]
        if not domain in table:
            table[domain] = {}
        domain = table[domain]
        new_ips = []
        for ip in ips:
            if not ip in domain:
                new_ips.append(ip)
            domain[ip] = time.time()
        return new_ips

    def get_ips(self, table):
        if not table in self.state:
            return []
        table = self.state[table]
        ips = []
        current_time = time.time()
        for domain in table.values():
            to_remove = []
            for (ip, update_time) in domain.items():
                if (update_time + default_ttl) > current_time:
                    ips.append(ip)
                else:
                    to_remove.append(ip)
            for ip in to_remove:
                del domain[ip]
        return ips

class Config:

    def __init__(self, config_file):
        self.config_file = config_file
        self.load()

    def load(self):
        self.tables = []
        self.domains = {}
        self.regexs = {}
        if not os.path.exists(self.config_file):
            return
        with open(self.config_file, 'r') as infile:
            config = json.load(infile)
        for table in config:
            self.tables.append(table)
            self.domains[table] = []
            self.regexs[table] = []
            if 'domains' in config[table]:
                for domain in config[table]['domains']:
                    self.domains[table].append(domain)
            if 'regexs' in config[table]:
                for regex in config[table]['regexs']:
                    self.regexs[table].append(re.compile(regex))

    def get_tables(self):
        return self.tables

    def get_domains(self, table):
        return self.domains[table]

    def get_regexs(self, table):
        return self.regexs[table]

def sync_state(config, state):
    # prime the state
    for table in config.get_tables():
        state.add_table(table)
        for domain in config.get_domains(table):
            state.update_domain(table, domain, [])

    # clear irrelviant state
    tables_to_remove = []
    for table in state.get_tables():
        if not table in config.get_tables():
            tables_to_remove.append(table)
            continue
        domains_to_remove = []
        for domain in state.get_domains(table):
            if domain in config.get_domains(table):
                continue
            found = False
            for regex in config.get_regexs(table):
                if regex.match(domain):
                    found = True
                    break
            if not found:
                domains_to_remove.append(domain)
        for domain in domains_to_remove:
            state.remove_domain(table, domain)
    for table in tables_to_remove:
        state.remove_table(table)

# TODO, should i use this?
async def update_ips(state, table, domain, ips):
    new_ips = state.update_domain(table, domain, ips)
    for new_ip in new_ips:
        await pft_add(table, new_ip)

async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', default=default_config_file, help='config file')
    parser.add_argument('-s', default=default_state_file, help='state file')
    args = parser.parse_args()

    config = Config(args.c)
    state = JsonState(args.s)
    sync_state(config, state)
    try:
        await _main(config, state)
    finally:
        state.save()
        for table in state.get_tables():
            await pft_flush(table)

async def _main(config, state):
    logging.basicConfig(level=logging.DEBUG)
    loop = asyncio.get_event_loop()
    
    finish = asyncio.Event()
    def on_signal(*args):
        finish.set()
    loop.add_signal_handler(signal.SIGINT, on_signal)
    loop.add_signal_handler(signal.SIGTERM, on_signal)
    
    reload_config = asyncio.Event()
    def reload_signal(*args):
        reload_config.set()
    loop.add_signal_handler(signal.SIGUSR1, reload_signal)

    async def tapper_callback(domain, ip):
        domain = domain[:-1]
        for table in state.get_tables():
            if domain in state.get_domains(table):
                new_ips = state.update_domain(table, domain, [str(ip)])
                for new_ip in new_ips:
                    await pft_add(table, new_ip)
            else:
                for regex in config.get_regexs(table):
                    if regex.match(domain):
                        new_ips = state.update_domain(table, domain, [str(ip)])
                        for new_ip in new_ips:
                            await pft_add(table, new_ip)
                        break

    tapper = dnstap_client.Tapper(tapper_callback)
    asyncio.create_task(tapper.loop())

    async def update_domains():
        while True:
            # update state
            for table in state.get_tables():
                for domain in state.get_domains(table):
                    ips = await get_ips(domain)
                    new_ips = state.update_domain(table, domain, ips)
                    for new_ip in new_ips:
                        await pft_add(table, new_ip)
            await asyncio.sleep(default_update_domains_period)
            
    asyncio.create_task(update_domains())

    async def reload_config_handler():
        while True:
            await reload_config.wait()
            logging.debug("reloading config")
            config.load()
            sync_state(config, state)
            reload_config.clear()

    asyncio.create_task(reload_config_handler())

    while not finish.is_set():
        for table in state.get_tables():
            pft_ips = await pft_list(table)
            table_ips = state.get_ips(table)
            for ip in pft_ips:
                if not ip in table_ips:
                    await pft_delete(table, ip)
            for ip in table_ips:
                if not ip in pft_ips:
                    await pft_add(table, ip)
        try:
            await asyncio.wait_for(finish.wait(), default_sync_period)
        except asyncio.TimeoutError:
            pass
        state.save()

if __name__ == '__main__':
    asyncio.run(main())
